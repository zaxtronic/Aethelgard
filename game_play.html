<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aethelgard: Jugando...</title>
    <!-- CSS (Bootstrap, Google Fonts, Estilos Personalizados) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=EB+Garamond:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        /* === Estilos Completos === */
        :root {
            --color-background: #121212;
            --color-background-section: #1a1a1a;
            --color-text-primary: #E0E0E0;
            --color-text-secondary: #AAAAAA;
            --color-accent-dark-red: #8A2B2B;
            --color-accent-gold: #DAA520;
            --color-accent-bronze: #CD7F32;
            --color-accent-parchment: #F5F5DC;
            --color-border-light: #444444;
            --color-border-dark: #333333;
            --font-heading: 'Cinzel Decorative', serif;
            --font-body: 'EB Garamond', serif;
        }

        html { scroll-padding-top: 80px; /* Ajuste para navbar fija */ }
        body {
            font-family: var(--font-body);
            background-color: var(--color-background);
            color: var(--color-text-primary);
            line-height: 1.7;
            font-size: 1.1rem;
        }
        h1, h2, h3, h4, h5, h6 { font-family: var(--font-heading); color: var(--color-accent-parchment); letter-spacing: 1px;}
        a { color: var(--color-accent-gold); text-decoration: none; transition: color 0.3s ease;}
        a:hover { color: var(--color-accent-parchment); text-decoration: underline;}

        .navbar {
            background-color: rgba(26, 26, 26, 0.9);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid var(--color-border-dark);
            padding-top: 0.8rem; padding-bottom: 0.8rem;
        }
        .navbar-brand { font-family: var(--font-heading); color: var(--color-accent-gold) !important; font-size: 1.5em;}
        .navbar-text span { color: var(--color-text-secondary); }
        .navbar-text strong { color: var(--color-accent-parchment); margin-left: 5px; }

        .container { max-width: 900px; margin-top: 20px; }

        /* Contenedor NARRATIVA o SELECCION PJ */
        #game-content {
            padding: 30px 20px;
            background-color: var(--color-background-section);
            border: 1px solid var(--color-border-dark);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            transition: opacity 0.5s ease-in-out;
            min-height: 300px;
        }
        /* Estilo para secciones NARRATIVAS dentro de game-content */
        .content-section {
            animation: fadeIn 0.7s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .content-section h2 {
            font-size: 2.5em;
            text-align: center;
            margin-bottom: 1.8rem;
            color: var(--color-accent-dark-red);
            border-bottom: 1px solid var(--color-border-light);
            padding-bottom: 0.5rem;
        }
         .content-section p {
             margin-bottom: 1.3em;
             text-align: justify;
        }

        /* Botones de Opci√≥n Narrativa */
        #narrative-options { margin-top: 2rem; border-top: 1px dashed var(--color-border-light); padding-top: 1.5rem; text-align: center; }
        #narrative-options button.opcion-button {
            margin: 8px 5px;
            font-family: var(--font-body);
            font-size: 1em;
            font-style: italic;
            background-color: transparent;
            color: var(--color-accent-bronze);
            border: 1px solid var(--color-accent-bronze);
            padding: 8px 18px;
            border-radius: 4px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        #narrative-options button.opcion-button:hover:not(:disabled) {
            background-color: var(--color-accent-bronze);
            color: var(--color-background-section);
            box-shadow: 0 0 8px rgba(205, 127, 50, 0.5);
        }
         #narrative-options button.opcion-button:disabled {
            opacity: 0.4;
            border-color: var(--color-text-secondary);
            color: var(--color-text-secondary);
            cursor: not-allowed;
        }
        #narrative-options .roll-required {
            font-size: 0.85em; color: var(--color-text-secondary); display: block; margin-top: 2px;
        }
        #narrative-options .roll-required strong { color: var(--color-accent-parchment); }


        /* --- Estilos para UI Combate --- */
        #combat-interface {
             background-color: #1f1f1f;
             border: 2px solid var(--color-accent-dark-red);
             border-radius: 8px;
             padding: 25px; margin-bottom: 30px;
             box-shadow: 0 3px 12px rgba(138, 79, 79, 0.5);
             display: none; /* Oculto por defecto */
             transition: opacity 0.5s ease-in-out;
             animation: fadeInCombat 0.6s ease-out;
         }
         @keyframes fadeInCombat { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }

         #combat-header { text-align: center; margin-bottom: 2rem; }
         #combat-header h2 { color: var(--color-accent-dark-red); font-size: 2.4em; border-bottom: none;}
         #combat-round-turn { font-size: 1.2em; color: var(--color-text-secondary); font-weight: bold; }

        #combatant-lists-container .h3 {
             font-family: var(--font-heading); font-size: 1.6em; margin-bottom: 0.8rem; border-bottom: 1px solid var(--color-border-light); padding-bottom: 0.4rem;
         }
         .list-unstyled { padding: 0; margin-bottom: 2rem; }

         .combatant {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; margin-bottom: 6px; border-radius: 5px;
            border: 1px solid var(--color-border-dark);
            background-color: var(--color-background-section);
            transition: all 0.2s ease-in-out;
        }
        .combatant.is-pj { border-left: 5px solid var(--color-accent-gold); }
        .combatant.is-enemy { border-left: 5px solid var(--color-accent-dark-red); }
        .combatant.current-turn {
            border-color: var(--color-accent-bronze);
            background-color: #333;
            transform: scale(1.02);
            box-shadow: 0 0 10px rgba(205, 127, 50, 0.4);
        }
        .combatant.current-turn .combatant-name { color: var(--color-accent-bronze); font-weight: bold;}
        .combatant.is-down { opacity: 0.5; text-decoration: line-through wavy rgba(255, 0, 0, 0.7); background-color: #111;}
        .combatant-name { color: var(--color-text-primary); flex-grow: 1; margin-right: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
        .combatant-info { text-align: right; flex-shrink: 0; }
        .combatant-hp { font-size: 0.95em; color: var(--color-text-secondary); font-weight: normal; display: block;}
        .combatant-status { font-size: 0.85em; font-style: italic; color: var(--color-text-secondary); display: block; }


        #player-actions {
            padding: 20px; border: 1px solid var(--color-border-light); border-radius: 6px; margin-top: 25px;
            background-color: rgba(0,0,0,0.2);
        }
        #player-actions h3 { color: var(--color-accent-parchment); font-size: 1.5em; text-align: center; margin-bottom: 18px;}
        #action-buttons { display: flex; justify-content: center; flex-wrap: wrap; gap: 12px;}

        #action-buttons button, #confirm-action-btn {
            font-family: var(--font-body); font-weight: bold; border-radius: 4px; transition: all 0.2s ease;
            padding: 6px 14px; font-size: 0.95em;
        }
        .btn-custom-primary { background-color: var(--color-accent-gold); border-color: var(--color-accent-gold); color: var(--color-background); }
        .btn-custom-primary:hover { background-color: #f0c040; border-color: #f0c040; color: #000; }
        .btn-custom-secondary { background-color: var(--color-accent-bronze); border-color: var(--color-accent-bronze); color: var(--color-background); }
        .btn-custom-secondary:hover { background-color: #e08f45; border-color: #e08f45; color: #000; }

        .btn-outline-info { color: #6BD4FE; border-color: #6BD4FE;} .btn-outline-info:hover { background-color: #6BD4FE; color: var(--color-background); }
        .btn-outline-success { color: #47C385; border-color: #47C385; } .btn-outline-success:hover { background-color: #47C385; color: var(--color-background); }
        .btn-outline-light { color: #f8f9fa; border-color: #f8f9fa; } .btn-outline-light:hover { background-color: #f8f9fa; color: var(--color-background); }
        .btn-outline-secondary { color: #adb5bd; border-color: #adb5bd; } .btn-outline-secondary:hover { background-color: #adb5bd; color: var(--color-background); }


        #action-details {
             background-color: #111; padding: 18px; border-radius: 5px;
             border: 1px solid var(--color-border-dark); margin-top: 20px;
             box-shadow: inset 0 1px 4px rgba(0,0,0,0.4);
        }
        #action-details .form-label { color: var(--color-text-secondary); font-size: 0.9em; margin-bottom: 4px; }
        #action-details .form-select-sm { background-color: #222; border-color: var(--color-border-light); color: var(--color-text-primary); }
        #confirm-action-btn { font-size: 1.05em !important; padding: 8px 16px !important;}

        #combat-log {
             margin-top: 2.5rem; padding: 20px;
             background-color: rgba(0,0,0,0.35); border: 1px solid var(--color-border-dark);
             border-radius: 6px; max-height: 250px;
             overflow-y: auto; font-size: 0.95em;
             color: var(--color-text-secondary);
             box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
         }
        #combat-log p { margin-bottom: 0.6em; line-height: 1.6;}
        #combat-log p strong { color: var(--color-accent-parchment); }
        #combat-log p.log-important { font-weight: bold; color: var(--color-accent-gold); border-left: 3px solid var(--color-accent-gold); padding-left: 8px; }
        #combat-log p.log-damage { color: #e08080; }
        #combat-log p.log-info { font-style: italic; }

         /* === Character Selection UI === */
        #character-selection-section h2 { color: var(--color-accent-gold); }
        .char-select-list { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 1rem;}
        .char-select-card {
             background-color: #2a2a2a; border: 1px solid var(--color-border-light); border-radius: 6px;
             padding: 15px; text-align: center; cursor: pointer; transition: all 0.3s ease;
             display: flex; flex-direction: column; align-items: center; width: 200px;
        }
        .char-select-card:hover, .char-select-card:focus {
             transform: translateY(-5px); border-color: var(--color-accent-gold); box-shadow: 0 4px 10px rgba(218, 165, 32, 0.3); outline: none;
        }
        .char-icon { font-size: 3em; margin-bottom: 10px; }
        .char-details .name { font-weight: bold; color: var(--color-accent-parchment); font-size: 1.1em;}
        .char-details .race-class { font-size: 0.9em; color: var(--color-text-secondary); }

         /* Spinner */
         .loading-spinner {
             display: none; /* Oculto por defecto */
             position: fixed; top: 0; left: 0; width: 100%; height: 100%;
             background-color: rgba(18, 18, 18, 0.8);
             z-index: 1060;
             justify-content: center; align-items: center; flex-direction: column;
         }
          .loading-spinner .spinner-border { width: 3rem; height: 3rem; color: var(--color-accent-gold); }
          .loading-spinner p { color: var(--color-text-secondary); margin-top: 10px; font-style: italic; }

         footer { text-align: center; margin-top: 4rem; padding: 1.5rem 0; border-top: 1px solid var(--color-border-dark); color: var(--color-text-secondary); font-size: 0.9em;}
    </style>
</head>
<body data-bs-theme="dark">

    <nav class="navbar navbar-expand-md sticky-top">
      <div class="container">
        <a class="navbar-brand" href="index.html">Aethelgard</a>
        <div class="navbar-text ms-auto">
          <!-- Info PJ Activo -->
          <span id="char-status">Cargando...</span>
          <!-- Enlace Reiniciar -->
          <a href="#" id="reset-game-link" class="ms-3 text-danger" title="Reiniciar Aventura (¬°Pierdes Progreso!)"><small>Reiniciar</small></a>
        </div>
      </div>
    </nav>

    <div class="container">

        <!-- √Årea Principal: Muestra SELECCI√ìN PJ, contenido NARRATIVO o UI de COMBATE -->
        <div id="game-content">
             <!-- Contenido inicial placeholder -->
             <p class="text-center p-5 text-secondary">Iniciando aventura...</p>
        </div><!-- fin #game-content -->

         <!-- ======= Interfaz de Combate ======= -->
         <div id="combat-interface"> <!-- display: none initially via CSS -->

             <!-- Cabecera Combate -->
             <div id="combat-header" class="mb-4">
                 <h2 class="mb-1">¬°EN COMBATE!</h2>
                 <div id="combat-round-turn" class="text-secondary">Ronda: ? | Turno de: Cargando...</div>
             </div>

            <!-- Lista Combatientes -->
            <div id="combatant-lists-container" class="row mb-4">
                <div class="col-lg-6 mb-3 mb-lg-0">
                     <h3 class="text-success">Grupo</h3>
                     <ul id="combatant-list-pjs" class="list-unstyled"></ul>
                 </div>
                <div class="col-lg-6">
                    <h3 class="text-danger">Enemigos</h3>
                    <ul id="combatant-list-enemies" class="list-unstyled"></ul>
                </div>
            </div>

             <!-- Acciones del Jugador -->
             <div id="player-actions" style="display: none;">
                 <h3 class="text-warning">Tu Turno: ¬°Elige Acci√≥n!</h3>
                 <div id="action-buttons" class="mb-3 text-center">
                     <button class="btn btn-sm btn-custom-primary" data-action-type="attack">Atacar</button>
                     <button class="btn btn-sm btn-custom-secondary" data-action-type="cast_spell">Hechizo</button>
                     <button class="btn btn-sm btn-outline-info" data-action-type="dodge">Esquivar</button>
                     <button class="btn btn-sm btn-outline-success" data-action-type="use_item">Objeto</button>
                     <button class="btn btn-sm btn-outline-light" data-action-type="move">Mover (Desc)</button>
                     <button class="btn btn-sm btn-outline-secondary" data-action-type="end_turn">Terminar Turno</button>
                 </div>
                 <!-- Detalles/Selecci√≥n para acci√≥n elegida -->
                 <div id="action-details" style="display:none;">
                      <!-- Selecci√≥n de Objetivo -->
                      <div id="targeting-module" style="display: none;">
                           <label for="target-select" class="form-label">Objetivo:</label>
                           <select id="target-select" class="form-select form-select-sm mb-2"></select>
                       </div>
                       <!-- Selecci√≥n de Hechizo -->
                       <div id="spell-module" style="display: none;">
                           <label for="spell-select" class="form-label">Hechizo:</label>
                           <select id="spell-select" class="form-select form-select-sm mb-2">
                               <option value="">-- Selecciona Hechizo --</option>
                           </select>
                        </div>
                       <!-- Selecci√≥n de Item -->
                        <div id="item-module" style="display: none;">
                            <label for="item-select" class="form-label">Objeto:</label>
                            <select id="item-select" class="form-select form-select-sm mb-2">
                               <option value="">-- Selecciona Objeto --</option>
                            </select>
                        </div>
                       <!-- Bot√≥n Confirmar Acci√≥n -->
                       <button id="confirm-action-btn" class="btn btn-success btn-sm w-100 mt-2">Confirmar Acci√≥n</button>
                 </div>
             </div>

             <!-- Log de Combate -->
             <div id="combat-log" class="mt-4">
                 <p><em>El combate comienza...</em></p>
             </div>

         </div>
        <!-- ======== FIN Interfaz de Combate ======== -->

        <!-- Loading Spinner -->
        <div id="loading" class="loading-spinner">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Cargando...</span>
            </div>
            <p>Procesando...</p>
        </div>

    </div><!-- /container -->

    <footer class="mt-5">
        <p>¬© 2024 Aethelgard Engine. Todos los derechos reservados.</p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // === JavaScript Principal (Refactorizado y Limpio) ===

        // --- Referencias DOM ---
        const gameContentDiv = document.getElementById('game-content');
        const loadingSpinner = document.getElementById('loading');
        const resetGameLink = document.getElementById('reset-game-link');
        const charStatusSpan = document.getElementById('char-status');
        const combatInterfaceDiv = document.getElementById('combat-interface');
        const combatHeaderTitle = document.getElementById('combat-header').querySelector('h2');
        const combatRoundTurnDiv = document.getElementById('combat-round-turn');
        const combatantListPJs = document.getElementById('combatant-list-pjs');
        const combatantListEnemies = document.getElementById('combatant-list-enemies');
        const playerActionsDiv = document.getElementById('player-actions');
        const actionButtonsDiv = document.getElementById('action-buttons');
        const actionDetailsDiv = document.getElementById('action-details');
        const targetingModule = document.getElementById('targeting-module');
        const targetSelect = document.getElementById('target-select');
        const spellModule = document.getElementById('spell-module');
        const spellSelect = document.getElementById('spell-select');
        const itemModule = document.getElementById('item-module');
        const itemSelect = document.getElementById('item-select');
        const confirmActionButton = document.getElementById('confirm-action-btn');
        const combatLogDiv = document.getElementById('combat-log');

        // --- Estado del Juego (Variables Globales) ---
        let characterStats = null; // Objeto del personaje activo en esta sesi√≥n
        let currentSectionId = null; // ID de secci√≥n narrativa actual o 'combat:<instance_id>'
        let campaignId = null; // ID de la campa√±a activa
        let playerCount = 1; // N√∫mero de jugadores
        let currentCombatState = null; // Estado completo del combate actual
        let initialPartyState = []; // Array con datos b√°sicos de todo el grupo (cargado al inicio)
        let activeCharacterIndex = -1; // √çndice de 'characterStats' en 'initialPartyState'
        let pendingCombatAction = null; // Detalles de acci√≥n de combate seleccionada antes de confirmar

        // --- Constantes API ---
        const API_BASE = ''; // Ajustar si la API est√° en otro dominio/puerto
        const API_GET_SECTION = `${API_BASE}/api/get_section`;
        const API_MAKE_CHOICE = `${API_BASE}/api/make_choice`;
        const API_COMBAT_ACTION = `${API_BASE}/api/combat/action`;
        // const API_COMBAT_STATE = `${API_BASE}/api/combat/state`; // Endpoint para reanudar combate (implementaci√≥n futura)

        // --- Funciones Utilidad ---
        function showLoading(message = 'Procesando...') {
            loadingSpinner.querySelector('p').textContent = message;
            loadingSpinner.style.display = 'flex';
            gameContentDiv.style.opacity = '0.5';
            combatInterfaceDiv.style.opacity = '0.5';
        }

        function hideLoading() {
            loadingSpinner.style.display = 'none';
            gameContentDiv.style.opacity = '1';
            combatInterfaceDiv.style.opacity = '1';
        }

        function rollD20() { return Math.floor(Math.random() * 20) + 1; }

        function getModifier(statScore) { return Math.floor(((statScore || 10) - 10) / 2); }

        function updateCharacterUI() {
            // Muestra estado del PJ o mensaje apropiado en la navbar
            if (characterStats && characterStats.Name && typeof characterStats.Level !== 'undefined') {
                const displayPV_actual = characterStats.PV_actual_calc ?? 0;
                const displayPV_max = characterStats.PV_max_calc ?? '?';
                const displayXP = characterStats.XP ?? 0;
                charStatusSpan.textContent = `PJ: ${characterStats.Name} | Nvl: ${characterStats.Level} | PV: ${displayPV_actual}/${displayPV_max} | XP: ${displayXP}`;
            } else if (activeCharacterIndex === -1 && !characterStats) { // Si a√∫n no se ha seleccionado
                charStatusSpan.textContent = "Selecciona tu personaje...";
            } else { // Si hay √≠ndice pero faltan datos (poco probable si la carga inicial funcion√≥)
                charStatusSpan.textContent = "Cargando PJ...";
                console.warn("updateCharacterUI: Faltan datos en characterStats:", characterStats);
            }
        }

        // --- Funciones de Visualizaci√≥n (Display) ---

        /** Muestra UI para seleccionar el personaje activo para esta sesi√≥n */
        function displayCharacterSelection(partyData) {
            hideLoading();
            combatInterfaceDiv.style.display = 'none';
            gameContentDiv.innerHTML = '';
            gameContentDiv.style.display = 'block';

            const selectionSection = document.createElement('section');
            selectionSection.classList.add('content-section');
            selectionSection.id = 'character-selection-section';

            let contentHTML = `
                <h2 class="text-center">¬øQui√©n Eres, Aventurero?</h2>
                <p class="text-center text-secondary mb-4">Este navegador necesita saber qu√© personaje del grupo controlar√°s.</p>
                <div class="char-select-list">`;

            if (!partyData || partyData.length === 0) {
                contentHTML += '<p class="text-danger text-center">Error: No se encontraron datos de personajes para seleccionar.</p>';
            } else {
                partyData.forEach((charData, index) => {
                    if (!charData || typeof charData.character_id === 'undefined') {
                        console.warn("Omitiendo datos de personaje inv√°lidos en la selecci√≥n:", charData);
                        return;
                    }
                    // Usar icono del personaje si existe, si no, un default
                    const icon = charData.icon || 'üë§';

                    contentHTML += `
                        <div class="char-select-card" data-char-index="${index}" role="button" tabindex="0" aria-label="Seleccionar ${charData.Name || 'personaje sin nombre'}">
                            <span class="char-icon">${icon}</span>
                            <div class="char-details">
                                <div class="name">${charData.Name || 'Sin Nombre'}</div>
                                <div class="race-class">${charData.Race || '?'} - ${charData.Class || '?'}</div>
                             </div>
                         </div>`;
                });
            }

            contentHTML += `</div>`;
            selectionSection.innerHTML = contentHTML;
            gameContentDiv.appendChild(selectionSection);

            addCharacterLoginListeners();
            console.log("UI de Selecci√≥n de Personaje mostrada.");
            updateCharacterUI(); // Actualiza navbar a "Selecciona..."
        }

        /** Muestra contenido Narrativo (descripci√≥n, opciones) */
        function displaySection(sectionData) {
             if (!sectionData || typeof sectionData.id === 'undefined') {
                console.error("displaySection llamada con datos inv√°lidos:", sectionData);
                return showError("Error al cargar la secci√≥n. Datos inv√°lidos recibidos.");
            }

            console.log("Displaying Narrative Section:", sectionData.id);
            hideLoading();

            combatInterfaceDiv.style.display = 'none';
            gameContentDiv.innerHTML = '';
            gameContentDiv.style.display = 'block';

            const sectionElement = document.createElement('section');
            sectionElement.classList.add('content-section');
            sectionElement.id = `section-${sectionData.id}`;

            let innerHTML = `<h2 ${sectionData.title_style || ''}>${sectionData.title || `Secci√≥n ${sectionData.id}`}</h2>`;
            // Asume que sectionData.description es HTML sanitizado proveniente del backend
            innerHTML += `<div>${sectionData.description || '<p><em>Descripci√≥n no disponible.</em></p>'}</div>`;

            // A√±ade Opciones si existen
            if (sectionData.options && sectionData.options.length > 0) {
                innerHTML += '<div id="narrative-options">';
                sectionData.options.forEach((option, index) => {
                    const isDisabled = option.disabled || false;
                    const checkInfo = option.check ? `Tirada: ${option.check.stat.toUpperCase()} CD ${option.check.dc}` : '';
                    // Escapar comillas simples en el JSON para el atributo HTML
                    const escapedOptionLogic = JSON.stringify(option).replace(/'/g, "'");

                    innerHTML += `<button class="opcion-button" data-option-index="${index}" data-option-logic='${escapedOptionLogic}' ${isDisabled ? 'disabled' : ''}>
                                      ${option.text || `Opci√≥n ${index + 1}`}
                                      ${checkInfo ? `<span class="roll-required">(${checkInfo})</span>` : ''}
                                </button>`;
                });
                innerHTML += '</div>';
            } else if (sectionData.next && sectionData.next.sectionId && sectionData.next.sectionId !== 'COMBAT_START') {
                // Bot√≥n Continuar para secciones lineales sin opciones
                innerHTML += `<div id="narrative-options" class="text-center">
                                  <button id="continue-story-btn" class="btn btn-custom-primary" data-next-section="${sectionData.next.sectionId}">Continuar...</button>
                              </div>`;
            }

            sectionElement.innerHTML = innerHTML;
            gameContentDiv.appendChild(sectionElement);

            addNarrativeOptionListeners();
            updateCharacterUI();
            document.title = `Aethelgard: ${characterStats?.Name || 'Jugando'} - ${sectionData.title || 'Aventura'}`;
            window.scrollTo({ top: gameContentDiv.offsetTop - 80, behavior: 'smooth' });
            console.log("<<< displaySection FINALIZADO para", sectionData.id);
        }

        /** Muestra la Interfaz de Combate */
        function displayCombat(combatState) {
            if (!combatState || !combatState.combat_instance_id || !combatState.combatants || !combatState.turn_order) {
                console.error("displayCombat llamada con estado inv√°lido:", combatState);
                return showError("Error al cargar el combate. Estado inv√°lido recibido.");
            }
            console.log("Displaying Combat UI. Ronda:", combatState.round_number, "Turno √çndice:", combatState.current_turn_index);

            hideLoading();

            gameContentDiv.style.display = 'none';
            combatInterfaceDiv.style.display = 'block';
            combatInterfaceDiv.style.opacity = '1';

            // --- Cabecera ---
            combatHeaderTitle.textContent = combatState.title || "¬°EN COMBATE!";
            document.title = `Aethelgard: Combate Ronda ${combatState.round_number}`;

            // --- Listas de Combatientes ---
            combatantListPJs.innerHTML = '';
            combatantListEnemies.innerHTML = '';
            const currentTurnTempId = combatState.turn_order[combatState.current_turn_index];
            let currentCombatant = combatState.combatants.find(c => c.temp_id === currentTurnTempId);

            combatState.combatants.forEach(c => {
                 const isCurrentTurn = c.temp_id === currentTurnTempId;
                 const isDown = c.current_pv <= 0;

                 const li = document.createElement('li');
                 li.classList.add('combatant');
                 li.dataset.combatantId = c.temp_id;
                 li.classList.toggle('is-pj', c.is_pj);
                 li.classList.toggle('is-enemy', !c.is_pj);
                 li.classList.toggle('current-turn', isCurrentTurn);
                 li.classList.toggle('is-down', isDown);

                 const hpPercent = c.max_pv > 0 ? Math.max(0, Math.min(100, (c.current_pv / c.max_pv) * 100)) : 0;
                 let hpColorClass = 'text-secondary';
                 if (!isDown) {
                     hpColorClass = hpPercent > 60 ? 'text-success' : hpPercent > 25 ? 'text-warning' : 'text-danger';
                 }

                 let statusText = '';
                 if (isDown) {
                     statusText = '(Ca√≠do)';
                 } else if (c.status_effects && c.status_effects.length > 0) {
                     statusText = `(${c.status_effects.join(', ')})`;
                 }

                 li.innerHTML = `
                     <span class="combatant-name">${c.indicator || ''} ${c.name}</span>
                     <div class="combatant-info">
                         <span class="combatant-hp ${hpColorClass} fw-bold">${Math.max(0, c.current_pv)} / ${c.max_pv} PV</span>
                         ${statusText ? `<span class="combatant-status">${statusText}</span>` : ''}
                     </div>
                 `;

                 if (c.is_pj) combatantListPJs.appendChild(li); else combatantListEnemies.appendChild(li);
             });

            // --- Indicador de Turno y Acciones del Jugador ---
            if (currentCombatant) {
                combatRoundTurnDiv.innerHTML = `Ronda: ${combatState.round_number} | Turno de: <strong class="${currentCombatant.is_pj ? 'text-success' : 'text-danger'}">${currentCombatant.name}</strong>`;

                // Mostrar acciones S√ìLO si es el turno del PJ activo en ESTE NAVEGADOR y no est√° ca√≠do
                const showActions = currentCombatant.is_pj &&
                                    currentCombatant.original_id === characterStats?.character_id &&
                                    currentCombatant.current_pv > 0;

                playerActionsDiv.style.display = showActions ? 'block' : 'none';
                if (showActions) {
                    console.log(`Turno de ${characterStats.Name} (ID: ${characterStats.character_id}). Mostrando acciones.`);
                    actionDetailsDiv.style.display = 'none'; // Ocultar detalles al inicio del turno
                    pendingCombatAction = null;
                    addCombatActionListeners();
                 }
             } else {
                 combatRoundTurnDiv.textContent = `Ronda: ${combatState.round_number} | Error: Turno inv√°lido.`;
                 playerActionsDiv.style.display = 'none';
                 console.error("No se pudo encontrar el combatiente del turno actual:", currentTurnTempId, combatState.combatants);
             }

            // --- Log de Combate ---
            combatLogDiv.innerHTML = '';
            (combatState.combat_log || ["El combate contin√∫a..."]).forEach(logEntry => {
                const p = document.createElement('p');
                if (typeof logEntry === 'string') {
                    if(logEntry.startsWith('*** Ronda') || logEntry.startsWith('--- Turno')) p.classList.add('log-important');
                    else if (logEntry.includes('da√±o') || logEntry.includes('falla') || logEntry.includes('ca√≠do') || logEntry.includes('Derrota')) p.classList.add('log-damage');
                    else if (logEntry.startsWith('Log:')) p.classList.add('log-info');
                    p.textContent = logEntry; // Usar textContent por seguridad si el log no debe tener HTML
                } else {
                    p.textContent = JSON.stringify(logEntry); // Fallback para entradas no string
                }
                combatLogDiv.appendChild(p);
            });
            combatLogDiv.scrollTop = combatLogDiv.scrollHeight; // Scroll al final

            updateCharacterUI();
            window.scrollTo({ top: combatInterfaceDiv.offsetTop - 80, behavior: 'smooth' });
            console.log("<<< displayCombat FINALIZADO");
        }

        /** Muestra un mensaje de error en el √°rea principal */
        function showError(message, allowRetry = true) {
            hideLoading();
            combatInterfaceDiv.style.display = 'none';
            gameContentDiv.style.display = 'block';
            gameContentDiv.style.opacity = '1';

            let errorHTML = `
                <section class="content-section text-center text-danger">
                    <h2>¬°Error!</h2>
                    <p>${message}</p>`; // message puede contener HTML (ej. enlaces)

            if (allowRetry) {
                errorHTML += `
                    <p class="mt-4 text-secondary">Intenta recargar la p√°gina o reiniciar la aventura si el problema persiste.</p>
                    <div class="mt-3">
                        <button class="btn btn-warning me-2" onclick="location.reload()">Recargar P√°gina</button>
                        <button class="btn btn-danger" onclick="resetGameConfirm(event)">Reiniciar Aventura</button>
                     </div>`;
            } else {
                errorHTML += `
                    <div class="mt-3">
                       <a href="index.html" class="btn btn-secondary">Volver al Inicio</a>
                    </div>`;
            }
            errorHTML += `</section>`;
            gameContentDiv.innerHTML = errorHTML;
            console.error("Error mostrado al usuario:", message);
        }

        // --- Interacci√≥n con API ---

        /** Procesa la respuesta de la API y actualiza el estado/UI del juego. */
        function processApiResponse(data, originatingApiCall = 'unknown') {
            console.log(`Processing API response from [${originatingApiCall}]:`, data);

            // 1. Actualizar Estado del Personaje (si aplica)
            let characterUpdated = false;
            if (data.updatedCharacterStats && characterStats && data.updatedCharacterStats.character_id === characterStats.character_id) {
                characterStats = data.updatedCharacterStats;
                localStorage.setItem('aethelgard_character_state', JSON.stringify(characterStats));
                characterUpdated = true;
                console.log("Estado del PJ activo actualizado localmente.");
                // Actualizar tambi√©n en la copia en memoria del grupo
                const indexInParty = initialPartyState.findIndex(char => char.character_id === characterStats.character_id);
                if (indexInParty > -1) {
                    initialPartyState[indexInParty] = { ...initialPartyState[indexInParty], ...characterStats };
                    console.log("Estado PJ actualizado tambi√©n en initialPartyState (en memoria).");
                }
            } else if (data.updatedPartyStats && Array.isArray(data.updatedPartyStats)) {
                // Si el servidor devuelve el estado COMPLETO del grupo
                console.log("Recibido estado completo del grupo. Actualizando initialPartyState.");
                initialPartyState = data.updatedPartyStats;
                localStorage.setItem('aethelgard_initial_party_state', JSON.stringify(initialPartyState));
                // Re-extraer nuestro PJ activo del grupo actualizado
                if (activeCharacterIndex > -1 && activeCharacterIndex < initialPartyState.length) {
                    const potentiallyNewCharData = initialPartyState[activeCharacterIndex];
                    // Comprobar si el ID sigue siendo el mismo antes de sobrescribir
                    if (characterStats && potentiallyNewCharData.character_id === characterStats.character_id) {
                        characterStats = potentiallyNewCharData;
                        localStorage.setItem('aethelgard_character_state', JSON.stringify(characterStats));
                        characterUpdated = true;
                        console.log("PJ activo refrescado desde estado de grupo recibido.");
                    } else {
                        console.error("Inconsistencia de ID al refrescar PJ desde estado de grupo.");
                        // Forzar reselecci√≥n podr√≠a ser una opci√≥n dr√°stica aqu√≠
                        return showError("Error de sincronizaci√≥n del grupo. Se recomienda reiniciar.", false);
                    }
                } else {
                     console.error("Error al refrescar PJ activo desde estado de grupo: √çndice inv√°lido.");
                     return showError("Error de sincronizaci√≥n del grupo. Se recomienda reiniciar.", false);
                }
            }
            // Actualizar UI si los datos del PJ cambiaron
            if (characterUpdated) updateCharacterUI();

            // 2. Determinar Siguiente Estado de la UI
            let nextSectionToLoad = null; // Variable para guardar el ID del nuevo estado
            if (data.redirect) {
                console.log("Redirecci√≥n ordenada por el servidor a:", data.redirect);
                window.location.href = data.redirect;
                return;
            }
            else if (data.startCombat && data.combatData) { // Iniciar Combate
                currentCombatState = data.combatData;
                nextSectionToLoad = `combat_${currentCombatState.combat_instance_id}`;
                console.log("Transici√≥n a COMBATE:", nextSectionToLoad);
                displayCombat(currentCombatState);
            }
            else if (data.combatEnded) { // Finalizar Combate
                const victory = data.victory; // true o false
                console.log(`Transici√≥n post-combate. Victoria: ${victory}`);
                currentCombatState = null;
                if (data.nextSectionData && data.nextSectionData.id) {
                    nextSectionToLoad = data.nextSectionData.id;
                    displaySection(data.nextSectionData);
                } else {
                    console.error("Fin de combate, pero no se recibi√≥ secci√≥n siguiente v√°lida.");
                    nextSectionToLoad = null; // Indica fin o error
                    showError(`El combate ha terminado (${victory ? 'Victoria' : 'Derrota'}), pero no se especific√≥ el siguiente paso. ¬øFin de la aventura?`, false);
                }
            }
            else if (data.combatState) { // Actualizar Combate
                currentCombatState = data.combatState;
                nextSectionToLoad = `combat_${currentCombatState.combat_instance_id}`;
                console.log("Actualizaci√≥n estado de COMBATE:", nextSectionToLoad);
                displayCombat(currentCombatState);
            }
            else if (data.nextSectionData && data.nextSectionData.id) { // Secci√≥n Narrativa
                currentCombatState = null; // Asegurarse que salimos de modo combate
                nextSectionToLoad = data.nextSectionData.id;
                console.log("Transici√≥n a SECCI√ìN NARRATIVA:", nextSectionToLoad);
                displaySection(data.nextSectionData);
            }
            else { // Respuesta inesperada
                console.error(`Respuesta del servidor OK pero con formato inesperado tras '${originatingApiCall}':`, data);
                showError(`Respuesta inesperada del servidor tras la acci√≥n '${originatingApiCall}'. Intenta recargar.`);
                return; // No cambiar de secci√≥n
            }

            // 3. Actualizar Estado Global y localStorage de forma centralizada
if (nextSectionToLoad !== null && nextSectionToLoad.toString() !== currentSectionId) { // <-- Comparar como strings
    console.log(`Actualizando currentSectionId de '${currentSectionId}' a: '${nextSectionToLoad.toString()}'`); // <-- Convertir
    currentSectionId = nextSectionToLoad.toString(); // <-- Convertir y guardar como STRING
    localStorage.setItem('aethelgard_current_section', currentSectionId); // Guardar como STRING
} else if (nextSectionToLoad === null) {
    console.log("No hay secci√≥n siguiente definida por el servidor, limpiando current section.");
    localStorage.removeItem('aethelgard_current_section');
    currentSectionId = null;
}
        }

        /** Carga datos de secci√≥n o env√≠a el resultado de una elecci√≥n narrativa. */
        async function fetchSectionData(sectionIdTarget, choiceResultData = null) {
            showLoading("Cargando...");

            const activeCharId = characterStats?.character_id;
            if (!campaignId) return showError("Error cr√≠tico: Falta ID de Campa√±a. Reinicia.", false);
            if (!activeCharId) return showError("Error cr√≠tico: Falta ID del Personaje activo. Intenta recargar o reiniciar.", true);
            if (!sectionIdTarget) return showError("Error interno: Intento de operar sin ID de secci√≥n.", true);

            console.log(`FETCH START: Camp=${campaignId}, players=${playerCount}, Target/Current=${sectionIdTarget}, CharID=${activeCharId}, Choice=`, choiceResultData);

            let apiPath = '';
            let payload = {};
            let apiCallType = '';

            if (choiceResultData !== null && typeof choiceResultData.optionIndex !== 'undefined') {
                // --- Realizando una Elecci√≥n Narrativa ---
                apiPath = API_MAKE_CHOICE;
                apiCallType = 'make_choice';
                payload = {
                    characterId: activeCharId,
                    currentSectionId: sectionIdTarget, // La secci√≥n DONDE se hizo la elecci√≥n
                    campaignId: campaignId,
                    playerCount: playerCount,
                    // Incluir resultados calculados por el frontend
                    optionIndex: choiceResultData.optionIndex,
                    roll: choiceResultData.roll,
                    success: choiceResultData.success,
                    // Incluir consecuencias pre-calculadas
                    earnedXp: choiceResultData.earnedXp,
                    penalty: choiceResultData.penalty,
                    targetSectionId: choiceResultData.targetSectionId, // Sugerencia del frontend
                    combat_setup: choiceResultData.combat_setup,
                    path: choiceResultData.path,
                    flags_set: choiceResultData.flags_set,
                    items_gained: choiceResultData.items_gained,
                    items_lost: choiceResultData.items_lost
                };
                console.log("   -> Enviando payload a /api/make_choice");
            } else {
                // --- Cargando una Secci√≥n Directamente ---
                apiPath = API_GET_SECTION;
                apiCallType = 'get_section';
                payload = {
                    sectionId: sectionIdTarget, // La secci√≥n a cargar
                    campaignId: campaignId,
                    characterId: activeCharId,
                    playerCount: playerCount
                };
                console.log("   -> Enviando payload a /api/get_section");
            }

            try {
                const response = await fetch(apiPath, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMsg = `Error HTTP ${response.status}: ${response.statusText}`;
                    try { const errorData = await response.json(); errorMsg = errorData.error || errorMsg; } catch (e) {}
                    throw new Error(errorMsg);
                }
                const data = await response.json();
                processApiResponse(data, apiCallType); // Centralizar manejo de respuesta
            } catch (error) {
                console.error(`Error en ${apiPath}:`, error);
                showError(`Fallo al comunicar con el servidor (${apiPath}): ${error.message || 'Error desconocido.'}. Revisa tu conexi√≥n.`);
            } finally {
                 hideLoading(); // Asegurar que el spinner se oculta
                console.log(`FETCH END: ${apiPath}`);
            }
        }

        /** Env√≠a una acci√≥n de combate confirmada al backend. */
        async function sendConfirmedCombatAction() {
            console.log("--- sendConfirmedCombatAction INICIADO ---");
            if (!pendingCombatAction) return console.warn("sendConfirmedCombatAction llamado sin acci√≥n pendiente.");
            if (!currentCombatState || !currentCombatState.combat_instance_id) return showError("Error: No hay combate activo.");
            if (!characterStats || !characterStats.character_id) return showError("Error: Personaje no identificado.");

            const combatId = currentCombatState.combat_instance_id;
            const actionToSend = { ...pendingCombatAction }; // Copia para enviar

            // --- Recoger Detalles Adicionales (si son necesarios y est√°n seleccionados) ---
            let detailError = false;

            const requiresTarget = targetingModule.style.display !== 'none';
            if (requiresTarget) {
                if (targetSelect.value) actionToSend.target_temp_id = targetSelect.value;
                else { alert("Por favor, selecciona un objetivo v√°lido."); detailError = true; }
            }

            const requiresSpell = spellModule.style.display !== 'none';
            if (!detailError && requiresSpell) {
                if (spellSelect.value) actionToSend.spell_id = spellSelect.value;
                else { alert("Por favor, selecciona un hechizo."); detailError = true; }
            }

            const requiresItem = itemModule.style.display !== 'none';
            if (!detailError && requiresItem) {
                if (itemSelect.value) actionToSend.item_id = itemSelect.value;
                else { alert("Por favor, selecciona un objeto."); detailError = true; }
            }

            if (detailError) return console.warn("Acci√≥n cancelada, faltan detalles.");

            // --- Enviar al Backend ---
            console.log("Enviando acci√≥n confirmada:", actionToSend);
            showLoading("Realizando acci√≥n...");
            playerActionsDiv.style.display = 'none'; // Ocultar acciones mientras procesa

            const payload = {
                combatId: combatId,
                characterId: characterStats.character_id,
                action: actionToSend
            };

            try {
                const response = await fetch(API_COMBAT_ACTION, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    let errorMsg = `Error HTTP ${response.status}: ${response.statusText}`;
                    try { const errorData = await response.json(); errorMsg = errorData.error || errorMsg; } catch (e) {}
                    throw new Error(errorMsg);
                }
                const data = await response.json();
                pendingCombatAction = null; // Limpiar acci√≥n pendiente S√ìLO si la API tuvo √©xito
                processApiResponse(data, 'combat_action');
            } catch (error) {
                console.error("Error en API_COMBAT_ACTION:", error);
                showError(`Fallo al realizar la acci√≥n de combate: ${error.message || 'Error desconocido.'}. El estado puede ser inconsistente.`);
                // No re-mostrar acciones autom√°ticamente, podr√≠a ser confuso. Dejar que el usuario recargue si es necesario.
                pendingCombatAction = null; // Limpiar por si acaso para evitar reenv√≠o accidental
            } finally {
                // hideLoading(); // processApiResponse o showError ya lo hacen
                console.log(`FETCH END: ${API_COMBAT_ACTION}`);
            }
        }

        // --- Manejadores de Eventos y Listeners ---

        /** A√±ade listeners a las tarjetas de selecci√≥n de personaje. */
        function addCharacterLoginListeners() {
            const charCards = gameContentDiv.querySelectorAll('#character-selection-section .char-select-card');
            charCards.forEach(card => {
                card.removeEventListener('click', handleCharacterLogin);
                card.removeEventListener('keydown', handleCharacterLoginKeyboard);
                card.addEventListener('click', handleCharacterLogin);
                card.addEventListener('keydown', handleCharacterLoginKeyboard);
            });
        }

        /** Maneja la selecci√≥n de personaje con teclado (Enter/Space). */
        function handleCharacterLoginKeyboard(event) {
             if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault(); // Evita scroll con barra espaciadora
                handleCharacterLogin(event);
            }
        }

        /** Maneja la selecci√≥n (click o teclado) de una tarjeta de personaje. */
        function handleCharacterLogin(event) {
            const card = event.currentTarget;
            const selectedIndex = parseInt(card.dataset.charIndex, 10);

            if (initialPartyState && initialPartyState[selectedIndex]) {
                activeCharacterIndex = selectedIndex;
                characterStats = initialPartyState[selectedIndex]; // Cargar datos base iniciales

                localStorage.setItem('aethelgard_active_character_index', activeCharacterIndex.toString());
                // Guardar tambi√©n el estado cargado (puede ser sobreescrito si hay uno m√°s detallado guardado)
                localStorage.setItem('aethelgard_character_state', JSON.stringify(characterStats));

                console.log(`Personaje Activo SELECCIONADO (√çndice ${selectedIndex}):`, characterStats?.Name);
                updateCharacterUI(); // Actualizar navbar

                // Cargar la √∫ltima secci√≥n conocida o la inicial
                let sectionToLoad = localStorage.getItem('aethelgard_current_section') || '1';
                if (sectionToLoad.startsWith('combat_')) {
                    console.warn("Reanudaci√≥n de combate no implementada. Volviendo a secci√≥n '1'.");
                    sectionToLoad = '1';
                    localStorage.setItem('aethelgard_current_section', sectionToLoad);
                }

                fetchSectionData(sectionToLoad, null); // Iniciar carga del juego
            } else {
                console.error("Error al seleccionar personaje: √çndice inv√°lido o datos corruptos.", selectedIndex, initialPartyState);
                alert("Error al seleccionar el personaje.");
            }
        }

        /** A√±ade listeners a los botones de opci√≥n narrativa y al bot√≥n Continuar. */
        function addNarrativeOptionListeners() {
            const narrativeOptionButtons = gameContentDiv.querySelectorAll('button.opcion-button:not(:disabled)');
            narrativeOptionButtons.forEach(button => {
                button.removeEventListener('click', handleNarrativeOptionChoice);
                button.addEventListener('click', handleNarrativeOptionChoice);
            });
            const continueBtn = gameContentDiv.querySelector('#continue-story-btn');
            if (continueBtn) {
                continueBtn.removeEventListener('click', handleNarrativeContinuation);
                continueBtn.addEventListener('click', handleNarrativeContinuation);
            }
        }

        /** Maneja el click en un bot√≥n de opci√≥n narrativa. */
        function handleNarrativeOptionChoice(event) {
            const button = event.target.closest('button.opcion-button');
            if (!button || button.disabled) return;
            console.log("--- handleNarrativeOptionChoice INICIADO ---");
            gameContentDiv.querySelectorAll('button.opcion-button').forEach(btn => btn.disabled = true);

            const optionIndex = parseInt(button.dataset.optionIndex, 10);
            let optionLogic = {};
            try {
                optionLogic = JSON.parse(button.dataset.optionLogic.replace(/'/g, "'"));
            } catch (e) {
                console.error("Error parseando option logic JSON:", e, button.dataset.optionLogic);
                showError("Error al procesar la opci√≥n."); return;
            }
            const check = optionLogic.check;
            console.log("Opci√≥n narrativa elegida:", optionIndex + 1, `"${optionLogic.text}"`);

            // Realizar Tirada (Client-Side: ¬°Inseguro! El backend deber√≠a validar/realizarla)
            let rollResult = null; let modifier = 0; let success = true; let nextSteps = {};
            if (check) {
                console.log("   -> Requiere tirada:", check);
                if (!characterStats) return showError("Error: Faltan datos del personaje para la tirada.");
                const statName = (check.stat || '').toUpperCase().split('_')[0];
                const statValue = characterStats[statName] || 10;
                modifier = getModifier(statValue);
                const diceRoll = rollD20();
                rollResult = diceRoll + modifier;
                success = rollResult >= check.dc;
                console.warn(`   -> ¬°ROLL CLIENT-SIDE! ${check.stat} (d20=${diceRoll}+${modifier}=${rollResult}) vs DC ${check.dc} -> ${success ? '√âXITO' : 'FALLO'}`);

                // Determinar l√≥gica de consecuencias (√©xito/fallo/parcial/cr√≠tico)
                if (success) {
                    nextSteps = optionLogic.next?.success || {};
                    if (optionLogic.next?.partial && rollResult >= (optionLogic.next.partial.dc_met || check.dc) && rollResult < check.dc) {
                         console.log("      -> Resultado PARCIAL aplicado.");
                         nextSteps = optionLogic.next.partial;
                     } else console.log("      -> Resultado de √âXITO aplicado.");
                 } else { // Fallo
                    nextSteps = optionLogic.next?.failure || {};
                    console.log("      -> Resultado de FALLO aplicado.");
                    if (optionLogic.next?.failure?.check_fail_trigger_trap_on_5_below) {
                        const failureMargin = (check.dc || 0) - (rollResult || 0);
                         if (failureMargin >= 5) {
                              nextSteps.penalty = optionLogic.next.failure.penalty || nextSteps.penalty;
                              console.log("      -> ¬°Fallo Cr√≠tico (por >=5)! Aplicando Penalizaci√≥n:", nextSteps.penalty);
                          } else {
                               // Asegurarse de no aplicar penalty cr√≠tico en fallo normal
                               if(optionLogic.next.failure.penalty && nextSteps.penalty === optionLogic.next.failure.penalty) nextSteps.penalty = null;
                               console.log("      -> Fallo Normal.");
                           }
                     }
                 }
            } else {
                success = true; nextSteps = optionLogic.next || {};
                console.log("   -> Sin tirada requerida.");
            }

            // Construir objeto resultado para enviar al backend
            const choiceResultObject = {
                optionIndex, roll: rollResult, success,
                earnedXp: nextSteps.xp || 0,
                penalty: nextSteps.penalty || null,
                targetSectionId: nextSteps.sectionId || null, // null para que backend decida? o usar currentSectionId? Depende de API
                combat_setup: nextSteps.combat_setup || null,
                path: nextSteps.path || null,
                flags_set: nextSteps.flags_set || {},
                items_gained: nextSteps.items_gained || [],
                items_lost: nextSteps.items_lost || []
            };
            console.log("Calculated Choice Result to send:", choiceResultObject);

            // Enviar resultado al backend (usando currentSectionId como el origen de la elecci√≥n)
            fetchSectionData(currentSectionId, choiceResultObject);
        }

        /** Maneja el click en el bot√≥n "Continuar". */
        function handleNarrativeContinuation(event) {
            const button = event.target.closest('#continue-story-btn');
            if (!button || button.disabled) return;
            const targetSection = button.dataset.nextSection;
            if (targetSection) {
                button.disabled = true;
                fetchSectionData(targetSection, null); // Cargar siguiente secci√≥n
            } else {
                console.error("Bot√≥n 'Continuar' sin data-next-section.");
                showError("Error: Secci√≥n destino no definida.");
            }
        }

        /** A√±ade listeners a los botones de acci√≥n de combate y al bot√≥n Confirmar. */
        function addCombatActionListeners() {
            actionButtonsDiv.querySelectorAll('button.btn').forEach(button => {
                button.removeEventListener('click', handleCombatActionSelection);
                button.addEventListener('click', handleCombatActionSelection);
            });
            confirmActionButton.removeEventListener('click', sendConfirmedCombatAction);
            confirmActionButton.addEventListener('click', sendConfirmedCombatAction);
        }

        /** Maneja la selecci√≥n de un tipo de acci√≥n de combate (Atacar, Hechizo, etc.). */
        function handleCombatActionSelection(event) {
            const button = event.target.closest('button');
            if (!button) return;
            const actionType = button.dataset.actionType;
            if (!actionType) return;

            console.log(`Selected combat action type: ${actionType}`);
            pendingCombatAction = { type: actionType };

            // --- Resetear detalles y ocultar m√≥dulos ---
            actionDetailsDiv.style.display = 'none';
            targetingModule.style.display = 'none'; targetSelect.innerHTML = '';
            spellModule.style.display = 'none'; spellSelect.innerHTML = '<option value="">-- Elige --</option>';
            itemModule.style.display = 'none'; itemSelect.innerHTML = '<option value="">-- Elige --</option>';

            // --- Acciones Inmediatas ---
            if (['dodge', 'move', 'end_turn'].includes(actionType)) {
                 sendConfirmedCombatAction(); // Enviar directamente
                 return;
            }

            // --- Preparar Detalles para Acciones Complejas ---
            if (!currentCombatState || !characterStats) return showError("Error: Falta estado de combate o personaje.");
            const actingCharCombatData = currentCombatState.combatants.find(c => c.original_id === characterStats.character_id);
            if (!actingCharCombatData) return showError("Error: No se encontraron datos del combatiente activo.");

            const potentialTargets = currentCombatState.combatants.filter(c => c.current_pv > 0);
            let needsTargeting = false, needsSpellSelection = false, needsItemSelection = false;
            let filterTargets = (target) => true; // Filtro por defecto

            switch (actionType) {
                case 'attack':
                    needsTargeting = true;
                    filterTargets = (t) => !t.is_pj && t.temp_id !== actingCharCombatData.temp_id; // Enemigos (no uno mismo)
                    break;
                case 'cast_spell':
                    needsTargeting = true; // Asumir que necesita (puede ser self)
                    needsSpellSelection = true;
                    const knownSpells = characterStats.spells_known_json || [];
                    if (knownSpells.length > 0) {
                        knownSpells.forEach(spell => {
                            spellSelect.add(new Option(spell.name, spell.id));
                        });
                    } else {
                         spellSelect.innerHTML = '<option value="">No conoces hechizos</option>';
                         needsSpellSelection = false; // No se puede seleccionar
                    }
                    // Filtro inicial: permitir todos (incluido self). Podr√≠a ajustarse seg√∫n el hechizo seleccionado (avanzado).
                    filterTargets = (t) => true;
                    break;
                case 'use_item':
                    needsTargeting = true; // Asumir que necesita (puede ser self)
                    needsItemSelection = true;
                    const usableItems = (characterStats.inventory_json || []).filter(item => item.usable_in_combat);
                    if (usableItems.length > 0) {
                         usableItems.forEach(item => itemSelect.add(new Option(item.name, item.id)));
                    } else {
                         itemSelect.innerHTML = '<option value="">No tienes objetos usables</option>';
                         needsItemSelection = false;
                    }
                    // Filtro inicial: permitir self y aliados (com√∫n para pociones). Podr√≠a ajustarse seg√∫n el item (avanzado).
                    filterTargets = (t) => t.temp_id === actingCharCombatData.temp_id || t.is_pj;
                    break;
            }

            // --- Poblar Selector de Objetivos ---
            let targetOptionsAvailable = false;
            if (needsTargeting) {
                potentialTargets.filter(filterTargets).forEach(c => {
                    const label = `${c.name} (${c.current_pv}/${c.max_pv} PV) ${c.is_pj ? '[Aliado]' : '[Enemigo]'}`;
                    targetSelect.add(new Option(label, c.temp_id));
                    targetOptionsAvailable = true;
                });
                if (targetOptionsAvailable) targetingModule.style.display = 'block';
                else {
                    console.warn("No hay objetivos v√°lidos para la acci√≥n:", actionType);
                    alert(`No hay objetivos v√°lidos disponibles para ${actionType === 'attack' ? 'atacar' : 'esta acci√≥n'}.`);
                    pendingCombatAction = null; return; // Cancelar si no hay objetivos
                }
            }

            // --- Mostrar M√≥dulos Relevantes ---
             let detailsShown = false;
             if (needsSpellSelection && spellSelect.options.length > 1) { spellModule.style.display = 'block'; detailsShown = true; }
             if (needsItemSelection && itemSelect.options.length > 1) { itemModule.style.display = 'block'; detailsShown = true; }
             if (targetOptionsAvailable) detailsShown = true; // Ya se mostr√≥ targetingModule si hab√≠a opciones

             if (detailsShown) {
                 actionDetailsDiv.style.display = 'block';
                 // Enfocar el primer control relevante
                 if (needsSpellSelection && spellSelect.options.length > 1) spellSelect.focus();
                 else if (needsItemSelection && itemSelect.options.length > 1) itemSelect.focus();
                 else if (targetOptionsAvailable) targetSelect.focus();
             } else if (pendingCombatAction) {
                 // Si se seleccion√≥ una acci√≥n compleja pero no hab√≠a opciones (hechizos/items) o blancos v√°lidos.
                 console.warn(`No se pueden mostrar detalles para ${actionType} (faltan opciones o blancos).`);
                 pendingCombatAction = null; // Cancelar acci√≥n imposible
                 // Quiz√°s desactivar el bot√≥n original si se sabe de antemano?
             }
        }

        // --- L√≥gica de Reinicio del Juego ---
        function resetGameConfirm(event) {
            if (event) event.preventDefault(); // Prevenir comportamiento del enlace
            if (confirm("¬øEst√°s seguro de que quieres reiniciar toda la aventura?\n¬°Perder√°s todo tu progreso guardado para esta campa√±a!")) {
                resetGame();
            }
        }

        function resetGame() {
            console.warn("<<< INICIANDO REINICIO DEL JUEGO >>>");
            try {
                const keysToRemove = [
                    'aethelgard_selected_campaign', 'aethelgard_player_count',
                    'aethelgard_current_section', 'aethelgard_character_state',
                    'aethelgard_active_character_index', 'aethelgard_initial_party_state',
                    'aethelgard_selected_chars' // A√±adir otras claves si se usan
                ];
                keysToRemove.forEach(key => {
                    console.log(`   - Removiendo de localStorage: ${key}`);
                    localStorage.removeItem(key);
                });

                // Limpiar variables de estado en memoria
                characterStats = null; currentSectionId = null; campaignId = null;
                playerCount = 1; currentCombatState = null; initialPartyState = [];
                activeCharacterIndex = -1; pendingCombatAction = null;

                console.log("Progreso local borrado. Redirigiendo a Inicio...");
                alert("Aventura reiniciada.");
                window.location.href = 'index.html'; // Ajustar si la p√°gina inicial es otra
            } catch (error) {
                console.error("Error cr√≠tico al reiniciar:", error);
                alert("Hubo un problema al borrar el progreso. Borra manualmente los datos del sitio si es necesario.");
                window.location.href = 'index.html';
            }
        }

        // --- ============================================ ---
        // --- INICIALIZACI√ìN AL CARGAR P√ÅGINA (game_play.html) ---
        // --- ============================================ ---
        window.addEventListener('load', async () => {
            console.log("===== game_play.html Cargado. Iniciando Setup =====");
            showLoading("Iniciando aventura...");

            // --- 1. Cargar Datos Esenciales de Sesi√≥n ---
            campaignId = localStorage.getItem('aethelgard_selected_campaign');
            playerCount = parseInt(localStorage.getItem('aethelgard_player_count') || '1', 10);
            let lastKnownSection = localStorage.getItem('aethelgard_current_section') || '1';
            let savedActiveCharIndexStr = localStorage.getItem('aethelgard_active_character_index');

            // --- 2. Validar Campa√±a Seleccionada ---
            if (!campaignId) return showError(`Campa√±a no seleccionada. <a href="select_campaign.html">Selecciona una campa√±a</a>.`, false);

            // --- 3. Cargar Estado Inicial del Grupo ---
            try {
                const partyStateJSON = localStorage.getItem('aethelgard_initial_party_state');
                if (!partyStateJSON) throw new Error("Datos del grupo (initialPartyState) no encontrados.");
                initialPartyState = JSON.parse(partyStateJSON);
                if (!Array.isArray(initialPartyState) || initialPartyState.length === 0) throw new Error("Datos del grupo inv√°lidos o vac√≠os.");
                if (!initialPartyState.every(char => char && typeof char.character_id !== 'undefined')) throw new Error("Datos del grupo corruptos: falta character_id.");
            } catch (e) {
                console.error("Error cr√≠tico cargando datos del grupo:", e);
                return showError(`Error cargando datos del grupo (${e.message}). <a href="select_campaign.html">Vuelve a seleccionar campa√±a</a>.`, false);
            }
            console.log(`Datos Sesi√≥n: Campa√±a=${campaignId}, Jugadores=${playerCount}, GrupoSize=${initialPartyState.length}, √ölt.Secci√≥n=${lastKnownSection}, √çndiceGuardado=${savedActiveCharIndexStr}`);

            // --- 4. Determinar Personaje Activo para esta Sesi√≥n ---
            activeCharacterIndex = -1; characterStats = null;
            if (savedActiveCharIndexStr !== null) {
                const savedIndex = parseInt(savedActiveCharIndexStr, 10);
                if (!isNaN(savedIndex) && savedIndex >= 0 && savedIndex < initialPartyState.length) {
                    activeCharacterIndex = savedIndex;
                    // Intentar cargar estado detallado del PJ, si no, usar el del grupo inicial
                    const savedCharStateJSON = localStorage.getItem('aethelgard_character_state');
                    if (savedCharStateJSON) {
                        try {
                            const savedCharState = JSON.parse(savedCharStateJSON);
                            if (savedCharState && savedCharState.character_id === initialPartyState[activeCharacterIndex].character_id) {
                                characterStats = savedCharState; // Usar estado guardado detallado
                                console.log(`PJ activo REANUDADO desde character_state (√çndice ${activeCharacterIndex}): ${characterStats?.Name}`);
                            } else {
                                console.warn("ID en character_state no coincide con initialPartyState. Usando initialPartyState.");
                                characterStats = initialPartyState[activeCharacterIndex]; // Fallback
                                localStorage.setItem('aethelgard_character_state', JSON.stringify(characterStats)); // Corregir
                            }
                        } catch (e) {
                            console.error("Error parseando character_state. Usando initialPartyState.", e);
                            characterStats = initialPartyState[activeCharacterIndex]; // Fallback
                            localStorage.setItem('aethelgard_character_state', JSON.stringify(characterStats)); // Corregir
                        }
                    } else {
                        characterStats = initialPartyState[activeCharacterIndex]; // Usar datos del grupo inicial
                        console.log(`PJ activo REANUDADO desde initialPartyState (√çndice ${activeCharacterIndex}): ${characterStats?.Name}`);
                        localStorage.setItem('aethelgard_character_state', JSON.stringify(characterStats)); // Guardar como estado actual
                    }
                } else {
                    console.warn("√çndice de PJ activo guardado inv√°lido. Se requerir√° selecci√≥n.");
                    localStorage.removeItem('aethelgard_active_character_index');
                    localStorage.removeItem('aethelgard_character_state');
                }
            }

            // --- 5. Si no hay PJ activo, Mostrar Selecci√≥n ---
            if (activeCharacterIndex === -1 || !characterStats) {
                console.log("No se encontr√≥ PJ activo. Mostrando pantalla de selecci√≥n...");
                displayCharacterSelection(initialPartyState);
                updateCharacterUI(); // Muestra "Selecciona..."
                return; // La inicializaci√≥n se detiene aqu√≠, handleCharacterLogin continuar√°
            }

            // --- 6. Si hay PJ activo, Continuar Carga ---
            console.log("Personaje activo confirmado:", characterStats.Name, `(ID: ${characterStats.character_id})`);
            updateCharacterUI();
            document.title = `Aethelgard: ${characterStats.Name} - ${(campaignId || 'Aventura').replace(/_/g, ' ')}`;

            // --- 7. A√±adir Listener de Reinicio ---
            if (resetGameLink) {
                resetGameLink.removeEventListener('click', resetGameConfirm);
                resetGameLink.addEventListener('click', resetGameConfirm);
            }

            // --- 8. Cargar Estado del Juego (Secci√≥n/Combate) ---
            // TODO: Implementar reanudaci√≥n real de combate usando API_COMBAT_STATE
            if (lastKnownSection && lastKnownSection.startsWith('combat_')) {
                console.warn(`Reanudaci√≥n de combate (${lastKnownSection}) NO implementada. Cargando secci√≥n '1'.`);
                // --- Bloque de reanudaci√≥n (comentado hasta que la API est√© lista) ---
                /*
                const combatInstanceId = lastKnownSection.split('_')[1];
                try {
                    showLoading("Reanudando combate...");
                    const response = await fetch(API_COMBAT_STATE, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        body: JSON.stringify({ combatId: combatInstanceId, characterId: characterStats.character_id })
                    });
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const combatData = await response.json();
                    // Asumiendo que la respuesta tiene una clave como 'combatState'
                    if (combatData && combatData.combatState) {
                         processApiResponse({ combatState: combatData.combatState }, 'combat_state_resume');
                         return; // Salir si la reanudaci√≥n fue exitosa
                     } else {
                          throw new Error("Respuesta de reanudaci√≥n de combate inv√°lida.");
                      }
                } catch (err) {
                    console.error("Fallo al reanudar combate:", err);
                    showError("No se pudo reanudar el combate guardado. Cargando secci√≥n inicial.");
                    lastKnownSection = '1';
                    localStorage.setItem('aethelgard_current_section', lastKnownSection);
                    fetchSectionData(lastKnownSection, null); // Cargar secci√≥n 1 como fallback
                }
                */
                // --- Fallback Temporal ---
                 alert("Reanudar combates guardados a√∫n no est√° implementado. Volviendo a la secci√≥n 1.");
                 lastKnownSection = '1';
                 localStorage.setItem('aethelgard_current_section', lastKnownSection);
                 fetchSectionData(lastKnownSection, null);
            } else {
                // Cargar la secci√≥n narrativa guardada (o la 1 por defecto)
                fetchSectionData(lastKnownSection || '1', null);
            }

            console.log("===== Setup Inicial Completo =====");
            // hideLoading() es llamado por la funci√≥n display final
        }); // --- Fin window.onload ---

    </script>
</body>
</html>